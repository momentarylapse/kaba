use os
use xhui
use yrenderer.*

let W = 800
let H = 600

class Window extends xhui.Window
	var ctx: owned[Context]
	var xhui_renderer: owned[XhuiRenderer]
	var hdr: owned[HDRResolver]
	var render_path: owned[RenderPath]
	var light: YLight
	var cube: shared[CubeEmitter]
	var t = 0.0
	
	func __init__()
		super.__init__("test", W, H)
		from_source("
Dialog win 'bla'
	Grid ? ''
		Button b 'Test' noexpandy
		---|
		Button b2 'Test' noexpandy
		---|
		DrawingArea area '' expandy
")
		event("b", func() print("hi"))
		event_xp("area", "hui:draw", xdraw)
		event_xp("area", "hui:initialize", xinitialize)
		event_xp("win", "hui:just-before-draw", xbefore_draw)
		
		xhui.run_repeated(0.01, func() redraw("area"))
	
	func override on_mouse_move(m: vec2)
		#print(m)

	func mut xinitialize(p: xhui.Painter)
		print("INIT")
		ctx = api_init_xhui(&p)
		ctx!.create_managers("", os.app_directory_dynamic | "packages/yrenderer/shader", "")
		xhui_renderer = new XhuiRenderer(ctx!)
		

		hdr = new HDRResolver(ctx!, W, H)
		hdr!.exposure = 0.2
#		hdr.bloom_factor = 10
	
		#render_path = new RenderPathForward(ctx!, 1024)
		render_path = new RenderPathDeferred(ctx!, 130, 100, 1024)
		render_path!.background_color = [0.125,0.125,0.125,1]
	
		xhui_renderer!.add_child(weak(hdr!))
		hdr!.add_child(weak(render_path!))
	
	
		cube = new shared CubeEmitter(ctx!)
		cube!.material.emission = [0,0,0.7,1]
		render_path!.add_opaque_emitter(cube!)
	
		light.init([300,0,300,1], 100, -1)
		light.pos = [0,8,-10]
	

	func mut xbefore_draw(p: xhui.Painter)
		for r in xhui_renderer
			let params = r.extract_params(&p)
		
			cube!.matrix = mat4.rotation([t*0.4543,t*0.743,0])
		
			render_path!.set_view((vec3(0,0,-7), quaternion.ID, pi/4, 0.1, 1000))
			render_path!.set_lights([&light])
		
		#	hdr!.exposure = exp(sin(t)*2-0.8)
			cube!.material.emission.g = (1 + sin(t))*0.5
			
			r.before_draw(&p)
			
			t += 0.01
		

	func mut xdraw(p: xhui.Painter)
		for r in xhui_renderer
			r.draw(&p)


func main()
	var w = new Window()
	xhui.run()
	